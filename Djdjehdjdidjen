--//=========================================================================\\
--|| UI Library
--\\=========================================================================//
{{file `main.txt`}}

--//=========================================================================\\
--|| SERVICES & VARIABLES
--\\=========================================================================//
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local Lighting = game:GetService("Lighting")
local StarterGui = game:GetService("StarterGui")
local CoreGui = game:GetService("CoreGui")
local VirtualInputManager = game:GetService("VirtualInputManager")
local TweenService = game:GetService("TweenService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- Global settings table
local Settings = {
    ToggleUI_Keyboard = Enum.KeyCode.RightControl,
    Aimbot_Key = Enum.UserInputType.MouseButton2,
    Aimbot_Controller = Enum.KeyCode.ButtonL2,
    Fly_Key = Enum.KeyCode.F,
}

-- State variables
local isMoving = false
local antiAfkEnabled, noClipEnabled = false, false
local noClipConnection = nil
local isMinimized = false
local nameChangerCoroutine = nil

-- Fly Variables
local flyEnabled = false
local currentFlySpeed = 50
local bodyVelocity, bodyGyro = nil, nil

-- ESP & Aimbot Variables
local skeletonESPEnabled, nameESPEnabled, healthESPEnabled, distanceESPEnabled, tracerESPEnabled, wallcheckEnabled, printerESPEnabled, carESPEnabled = true, true, true, true, true, false, false, false
local aimbotEnabled, fovCircleEnabled, aimbotConnection, aimbotTargetPart, aimbotFOV = false, false, nil, "Head", 30
local fullbrightEnabled, defaultBrightness, defaultOutdoorAmbient = false, Lighting.Brightness, Lighting.OutdoorAmbient
local espRenderDistance, espLineColor, espTextColor, espThickness, espTextSize = 1000, Color3.new(1,0,0), Color3.new(1,1,1), 2, 14
local espPrinterColor = Color3.fromRGB(255, 105, 180) -- Pink color for printers
local espCarColor = Color3.fromRGB(0, 170, 255) -- Light blue for cars
local skeletonConnections, boxConnections, tracerConnections, printerEspDrawings, carEspDrawings = {}, {}, {}, {}, {}

-- FOV Circle Drawing Object
local fovCircle = Drawing.new("Circle")
fovCircle.Visible = false
fovCircle.Thickness = 1
fovCircle.Color = Color3.new(1, 1, 1)
fovCircle.Filled = false
fovCircle.NumSides = 64
fovCircle.ZIndex = 0

-- Connections table for easy cleanup
local connections = {}

-- Forward declare the GUI
local VroyFamilyWindow

--//=========================================================================\\
--|| CORE FUNCTIONS (Teleport, ESP, Aimbot, etc.)
--\\=========================================================================//
-- New Teleport Function
local function sitAndTeleport(targetPosition, targetLookVector)
    if isMoving then
        VroyFamilyWindow:Notify({Title = "Vroy Family", Content = "Please wait for the current action to finish."})
        return
    end
    isMoving = true
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    if not character then isMoving = false; return end
    local humanoid = character:WaitForChild("Humanoid")
    local rootPart = character:WaitForChild("HumanoidRootPart")
    if not (humanoid and rootPart) then isMoving = false; return end

    -- Make the player sit
    humanoid.Sit = true
    -- Wait a short moment to ensure they are sitting
    task.wait(0.2)

    -- Teleport to the destination with the specified look vector
    if rootPart and rootPart.Parent then
        rootPart.CFrame = CFrame.new(targetPosition, targetPosition + targetLookVector)
    end

    -- Short delay before allowing another action
    task.wait(0.1)
    isMoving = false
end

-- Function to disable flying
local function disableFly()
    local character = LocalPlayer.Character
    if not flyEnabled or not character then return end
    flyEnabled = false
    if bodyVelocity then bodyVelocity:Destroy(); bodyVelocity = nil end
    if bodyGyro then bodyGyro:Destroy(); bodyGyro = nil end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then humanoid.PlatformStand = false end
end

-- Function to enable flying
local function enableFly()
    local character = LocalPlayer.Character
    if flyEnabled or not character then return end
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not rootPart or not humanoid then return end
    flyEnabled = true
    humanoid.PlatformStand = true
    bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
    bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bodyVelocity.Parent = rootPart
    bodyGyro = Instance.new("BodyGyro")
    bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
    bodyGyro.P, bodyGyro.D = 10000, 500
    bodyGyro.CFrame = rootPart.CFrame
    bodyGyro.Parent = rootPart
    task.spawn(function()
        while flyEnabled and bodyVelocity and bodyGyro do
            local direction = Vector3.new(0, 0, 0)
            if UserInputService:IsKeyDown(Enum.KeyCode.W) then direction = direction + Camera.CFrame.LookVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.S) then direction = direction - Camera.CFrame.LookVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.A) then direction = direction - Camera.CFrame.RightVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.D) then direction = direction + Camera.CFrame.RightVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.Space) then direction = direction + Vector3.new(0, 1, 0) end
            if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then direction = direction - Vector3.new(0, -1, 0) end
            if direction.Magnitude > 0 then direction = direction.Unit * currentFlySpeed end
            if bodyVelocity then bodyVelocity.Velocity = direction end
            if bodyGyro and rootPart then
                bodyGyro.CFrame = CFrame.new(rootPart.Position, rootPart.Position + Camera.CFrame.LookVector)
            end
            RunService.Heartbeat:Wait()
        end
    end)
end

-- ESP Drawing Functions
local function newLine()
    local line = Drawing.new("Line"); line.Visible = false; line.Thickness = espThickness; line.Color = espLineColor; return line
end
local function newText()
    local text = Drawing.new("Text"); text.Visible = false; text.Size = espTextSize; text.Color = espTextColor; text.Center = true; text.Outline = true; return text
end
local function isWallBetween(fromPos, toPos, ignoreCharacter)
    local rayParams = RaycastParams.new();
    rayParams.FilterType = Enum.RaycastFilterType.Exclude;
    rayParams.FilterDescendantsInstances = {LocalPlayer.Character, ignoreCharacter};
    rayParams.IgnoreWater = true
    return workspace:Raycast(fromPos, (toPos - fromPos).Unit * (toPos - fromPos).Magnitude, rayParams) ~= nil
end

-- Skeleton ESP
local function createSkeleton(player)
    if skeletonConnections[player] then return end
    local lines = {
        HeadToUpperTorso=newLine(), UpperToLowerTorso=newLine(), LeftShoulder=newLine(), LeftUpperToLowerArm=newLine(), LeftLowerToHand=newLine(), RightShoulder=newLine(), RightUpperToLowerArm=newLine(), RightLowerToHand=newLine(), LeftHip=newLine(), LeftUpperToLowerLeg=newLine(), LeftLowerToFoot=newLine(), RightHip=newLine(), RightUpperToLowerLeg=newLine(), RightLowerToFoot=newLine()
    }
    local conn = RunService.RenderStepped:Connect(function()
        local localHRP = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        local char = player.Character
        if not skeletonESPEnabled or not localHRP or not char or not char:FindFirstChild("HumanoidRootPart") or (localHRP.Position - char.HumanoidRootPart.Position).Magnitude > espRenderDistance or (wallcheckEnabled and isWallBetween(localHRP.Position, char.HumanoidRootPart.Position, char)) then
            for _, line in pairs(lines) do line.Visible = false end; return
        end
        local function getPos(partName)
            local part = char:FindFirstChild(partName);
            if part and part:IsA("BasePart") then
                local pos, onScreen = Camera:WorldToViewportPoint(part.Position);
                if onScreen then return Vector2.new(pos.X, pos.Y), true end
            end;
            return nil, false
        end
        local function draw(name, fromPart, toPart)
            local fromPos, fromVisible = getPos(fromPart);
            local toPos, toVisible = getPos(toPart);
            local line = lines[name];
            if fromPos and toPos and fromVisible and toVisible then
                line.From = fromPos;
                line.To = toPos;
                line.Visible = true;
                line.Color = espLineColor;
                line.Thickness = espThickness
            else
                line.Visible = false
            end
        end
        draw("HeadToUpperTorso", "Head", "UpperTorso");
        draw("UpperToLowerTorso", "UpperTorso", "LowerTorso");
        draw("LeftShoulder", "UpperTorso", "LeftUpperArm");
        draw("LeftUpperToLowerArm", "LeftUpperArm", "LeftLowerArm");
        draw("LeftLowerToHand", "LeftLowerArm", "LeftHand");
        draw("RightShoulder", "UpperTorso", "RightUpperArm");
        draw("RightUpperToLowerArm", "RightUpperArm", "RightLowerArm");
        draw("RightLowerToHand", "RightLowerArm", "RightHand");
        draw("LeftHip", "LowerTorso", "LeftUpperLeg");
        draw("LeftUpperToLowerLeg", "LeftUpperLeg", "LeftLowerLeg");
        draw("LeftLowerToFoot", "LeftLowerLeg", "LeftFoot");
        draw("RightHip", "LowerTorso", "RightUpperLeg");
        draw("RightUpperToLowerLeg", "RightUpperLeg", "RightLowerLeg");
        draw("RightLowerToFoot", "RightLowerLeg", "RightFoot")
    end)
    skeletonConnections[player] = { connection = conn, lines = lines }
end
local function cleanupSkeleton(player)
    if skeletonConnections[player] then
        skeletonConnections[player].connection:Disconnect();
        for _, line in pairs(skeletonConnections[player].lines) do line:Remove() end;
        skeletonConnections[player] = nil
    end
end

-- Info ESP (Name, Health, Distance)
local function createInfoESP(player)
    if boxConnections[player] then return end
    local nameText, healthText, distanceText = newText(), newText(), newText()
    local conn = RunService.RenderStepped:Connect(function()
        local localHRP = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        local char = player.Character
        local humanoid = char and char:FindFirstChildOfClass("Humanoid")
        if not localHRP or not char or not humanoid or humanoid.Health <= 0 or not char:FindFirstChild("Head") then
            nameText.Visible, healthText.Visible, distanceText.Visible = false, false, false; return
        end
        local hrp, head = char.HumanoidRootPart, char.Head
        local dist = (localHRP.Position - hrp.Position).Magnitude
        if dist > espRenderDistance or (wallcheckEnabled and isWallBetween(localHRP.Position, hrp.Position, char)) then
            nameText.Visible, healthText.Visible, distanceText.Visible = false, false, false; return
        end
        local headPos, onScreenHead = Camera:WorldToViewportPoint(head.Position + Vector3.new(0, 0.5, 0))
        local hrpPos, onScreenHRP = Camera:WorldToViewportPoint(hrp.Position - Vector3.new(0, 1, 0))
        if not (onScreenHead and onScreenHRP) then
            nameText.Visible, healthText.Visible, distanceText.Visible = false, false, false; return
        end
        local x, y, h = headPos.X, headPos.Y, math.abs(headPos.Y - hrpPos.Y)
        if nameESPEnabled then
            nameText.Text = player.Name; nameText.Position = Vector2.new(x, y - 15); nameText.Visible = true; nameText.Color = espTextColor; nameText.Size = espTextSize
        end
        if healthESPEnabled then
            local health, maxHealth = math.floor(humanoid.Health), math.floor(humanoid.MaxHealth);
            healthText.Text = string.format("HP: %d/%d", health, maxHealth);
            healthText.Position = Vector2.new(x, y - 30);
            healthText.Color = health > maxHealth * 0.75 and Color3.new(0,1,0) or (health > maxHealth * 0.25 and Color3.new(1,1,0) or Color3.new(1,0,0));
            healthText.Visible = true;
            healthText.Size = espTextSize
        end
        if distanceESPEnabled then
            distanceText.Text = string.format("Dist: %d studs", math.floor(dist));
            distanceText.Position = Vector2.new(x, y + h + 15);
            distanceText.Visible = true;
            distanceText.Color = espTextColor;
            distanceText.Size = espTextSize
        end
    end)
    boxConnections[player] = { connection = conn, nameText = nameText, healthText = healthText, distanceText = distanceText }
end
local function cleanupInfoESP(player)
    if boxConnections[player] then
        boxConnections[player].connection:Disconnect();
        boxConnections[player].nameText:Remove();
        boxConnections[player].healthText:Remove();
        boxConnections[player].distanceText:Remove();
        boxConnections[player] = nil
    end
end

-- Tracer ESP
local function createTracerESP(player)
    if tracerConnections[player] then return end
    local tracerLine = newLine()
    local conn = RunService.RenderStepped:Connect(function()
        local localHRP = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        local targetHRP = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
        if not tracerESPEnabled or not localHRP or not targetHRP or (localHRP.Position - targetHRP.Position).Magnitude > espRenderDistance or (wallcheckEnabled and isWallBetween(localHRP.Position, targetHRP.Position, player.Character)) then
            tracerLine.Visible = false; return
        end
        local rootPos, onScreen = Camera:WorldToViewportPoint(targetHRP.Position)
        if onScreen then
            tracerLine.From, tracerLine.To, tracerLine.Visible = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y), Vector2.new(rootPos.X, rootPos.Y), true;
            tracerLine.Color = espLineColor;
            tracerLine.Thickness = espThickness
        else
            tracerLine.Visible = false
        end
    end)
    tracerConnections[player] = { connection = conn, line = tracerLine }
end
local function cleanupTracerESP(player)
    if tracerConnections[player] then
        tracerConnections[player].connection:Disconnect();
        tracerConnections[player].line:Remove();
        tracerConnections[player] = nil
    end
end

-- Aimbot Logic
local function aimbotLoop()
    if not aimbotEnabled then return end
    local localHRP = LocalPlayer.Character and LocalPlayer.Character.HumanoidRootPart
    if not localHRP then return end
    local closestPlayer, shortestDistance = nil, math.huge
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character:FindFirstChildOfClass("Humanoid").Health > 0 then
            local targetHRP = player.Character.HumanoidRootPart
            local distance = (localHRP.Position - targetHRP.Position).Magnitude
            if distance < shortestDistance and distance <= espRenderDistance then
                local targetPart = player.Character:FindFirstChild(aimbotTargetPart)
                if targetPart then
                    local directionToTarget = (targetPart.Position - Camera.CFrame.p).Unit
                    if math.deg(math.acos(Camera.CFrame.LookVector:Dot(directionToTarget))) <= aimbotFOV and not (wallcheckEnabled and isWallBetween(localHRP.Position, targetPart.Position, player.Character)) then
                        closestPlayer, shortestDistance = player, distance
                    end
                end
            end
        end
    end
    if closestPlayer then
        local targetPart = closestPlayer.Character:FindFirstChild(aimbotTargetPart)
        if targetPart then
            Camera.CFrame = Camera.CFrame:Lerp(CFrame.new(Camera.CFrame.p, targetPart.Position), 0.5)
        end
    end
end

-- ESP Management Functions
local function updatePlayerESP(player, enable)
    if player == LocalPlayer then return end
    cleanupSkeleton(player); cleanupInfoESP(player); cleanupTracerESP(player)
    if enable then
        if skeletonESPEnabled then createSkeleton(player) end
        if nameESPEnabled or healthESPEnabled or distanceESPEnabled then createInfoESP(player) end
        if tracerESPEnabled then createTracerESP(player) end
    end
end
local function updateAllEspVisuals()
    for _, player in pairs(Players:GetPlayers()) do
        updatePlayerESP(player, true)
    end
end

--//=========================================================================\\
--|| GUI CREATION & MANAGEMENT (Redesigned with new library)
--\\=========================================================================//

-- Create the main window instance and set the theme to all red.
local WindUI = loadstring(game:HttpGet("https://raw.githubusercontent.com/1337-vroy/WindUI/main/Loader.lua"))()

WindUI.SetTheme(
    WindUI.AddTheme(
        {
            Name = "VroyFamilyRed",
            Accent = "#ef4444",
            Dialog = "#b91c1c",
            Outline = "#fee2e2",
            Text = "#fee2e2",
            Placeholder = "#fca5a5",
            Background = "#7f1d1d",
            Button = "#ef4444",
            Icon = "#fecaca",
        }
    )
)

VroyFamilyWindow = WindUI.CreateWindow(
    {
        Title = "Vroy Family",
        Icon = "shield-check",
        Author = ".ftgs#0",
        Transparent = false,
        Folder = "VroyFamily",
        ToggleKey = Enum.KeyCode.RightControl,
        Resizable = true,
        Background = Color3.fromHex("#ef4444")
    }
)

-- Define tabs for the new UI
local combatTab = VroyFamilyWindow:Tab({
    Title = "Combat",
    Icon = "swords",
    ShowTabTitle = true,
})

local visualsTab = VroyFamilyWindow:Tab({
    Title = "Visuals",
    Icon = "eye",
    ShowTabTitle = true,
})

local teleportTab = VroyFamilyWindow:Tab({
    Title = "Teleport",
    Icon = "compass",
    ShowTabTitle = true,
})

local moneyTab = VroyFamilyWindow:Tab({
    Title = "Money",
    Icon = "wallet",
    ShowTabTitle = true,
})

local miscTab = VroyFamilyWindow:Tab({
    Title = "Misc",
    Icon = "grip",
    ShowTabTitle = true,
})


--- Combat Tab Content ---
local combatSection = combatTab:Section({Title = "Aimbot",})
combatSection:Toggle({
    Title = "Enable Aimbot",
    Value = false,
    Callback = function(state) aimbotEnabled = state end,
})

combatSection:Toggle({
    Title = "Show FOV Circle",
    Value = false,
    Callback = function(state) fovCircleEnabled = state end,
})

combatSection:Slider({
    Title = "Aimbot FOV",
    Value = {Min = 1, Max = 180, Default = aimbotFOV},
    Step = 1,
    Callback = function(value) aimbotFOV = value end,
})

combatSection:Dropdown({
    Title = "Target Part",
    Values = {"Head", "HumanoidRootPart", "Torso"},
    Value = "Head",
    Callback = function(value) aimbotTargetPart = value end,
})


--- Visuals Tab Content ---
local playerEspSection = visualsTab:Section({Title = "Player ESP"})
playerEspSection:Toggle({
    Title = "Skeleton ESP",
    Value = true,
    Callback = function(s) skeletonESPEnabled = s; updateAllEspVisuals() end,
})

playerEspSection:Toggle({
    Title = "Name ESP",
    Value = true,
    Callback = function(s) nameESPEnabled = s; updateAllEspVisuals() end,
})

playerEspSection:Toggle({
    Title = "Health ESP",
    Value = true,
    Callback = function(s) healthESPEnabled = s; updateAllEspVisuals() end,
})

playerEspSection:Toggle({
    Title = "Distance ESP",
    Value = true,
    Callback = function(s) distanceESPEnabled = s; updateAllEspVisuals() end,
})

playerEspSection:Toggle({
    Title = "Tracers",
    Value = true,
    Callback = function(s) tracerESPEnabled = s; updateAllEspVisuals() end,
})

playerEspSection:Toggle({
    Title = "Wallcheck",
    Value = false,
    Callback = function(s) wallcheckEnabled = s end,
})

visualsTab:Divider()
local worldEspSection = visualsTab:Section({Title = "World & Settings"})

worldEspSection:Toggle({
    Title = "Printer ESP",
    Value = false,
    Callback = function(s) printerESPEnabled = s end,
})

worldEspSection:Toggle({
    Title = "Car ESP",
    Value = false,
    Callback = function(s) carESPEnabled = s end,
})

worldEspSection:Colorpicker({
    Title = "Line Color",
    Default = Color3.fromHex("#ff0000"),
    Callback = function(color) espLineColor = color; updateAllEspVisuals() end,
})

worldEspSection:Colorpicker({
    Title = "Text Color",
    Default = Color3.new(1,1,1),
    Callback = function(color) espTextColor = color; updateAllEspVisuals() end,
})

worldEspSection:Slider({
    Title = "Line Size",
    Value = {Min = 1, Max = 5, Default = espThickness},
    Step = 1,
    Callback = function(v) espThickness = v; updateAllEspVisuals() end,
})

worldEspSection:Slider({
    Title = "Text Size",
    Value = {Min = 10, Max = 20, Default = espTextSize},
    Step = 1,
    Callback = function(v) espTextSize = v; updateAllEspVisuals() end,
})

--- Teleport Tab Content ---
local locationSection = teleportTab:Section({Title = "Locations"})
local utilitySection = teleportTab:Section({Title = "Utility"})

local teleportLocations = {
    ["Loading Screen (LMFAO)"] = Vector3.new(1397.54, 213.73, 1022.86),
    ["Clothes Store"] = Vector3.new(882.73, 317.48, -309.71),
    ["sell ripz"] = Vector3.new(868.59, 317.36, -236.99),
    ["rays Auto Center"] = Vector3.new(648.39, 317.42, 354.92),
    ["Gun Store"] = Vector3.new(192.39, 317.45, 935.83),
    ["Black Market"] = Vector3.new(318.29, 317.40, 1107.25),
    ["laundromat"] = Vector3.new(-0.71, 317.43, 933.01),
    ["houses"] = Vector3.new(216.12, 317.43, 172.89),
    ["gas station"] = Vector3.new(284.65, 317.43, 359.92),
    ["Wood Chopper"] = Vector3.new(745.51, 317.39, 843.63),
    ["food shop"] = Vector3.new(713.68, 317.43, -133.08),
    ["Printers"] = Vector3.new(-135.16, 317.39, 162.96),
    ["guapo"] = Vector3.new(177.20, 317.43, -162.10),
    ["Heist"] = Vector3.new(47.77, 317.39, 786.96),
    ["p mobile"] = Vector3.new(721.06, 317.36, -74.68)
}

for name, pos in pairs(teleportLocations) do
    locationSection:Button({
        Title = name,
        Callback = function()
            if LocalPlayer.Character then
                sitAndTeleport(pos, LocalPlayer.Character.PrimaryPart.CFrame.LookVector)
            end
        end,
    })
end

utilitySection:Button({
    Title = "ServerHop",
    Callback = function()
        task.spawn(function()
            local url = "https://games.roblox.com/v1/games/"..game.PlaceId.."/servers/Public?sortOrder=Asc&limit=100"
            local success, result = pcall(function() return HttpService:GetAsync(url) end)
            if not success then
                VroyFamilyWindow:Notify({Title = "Vroy Family", Content = "Failed to fetch servers."})
                return
            end
            local servers = HttpService:JSONDecode(result).data
            local newServers = {}
            for _, server in ipairs(servers) do
                if type(server)=='table' and server.id and server.id~=game.JobId and server.playing<server.maxPlayers then
                    table.insert(newServers, server.id)
                end
            end
            if #newServers > 0 then
                TeleportService:TeleportToPlaceInstance(game.PlaceId, newServers[math.random(1, #newServers)], LocalPlayer)
            else
                VroyFamilyWindow:Notify({Title = "Vroy Family", Content = "No other servers found."})
            end
        end)
    end,
})


--- Money Tab Content ---
local moneySection = moneyTab:Section({Title = "Automation"})
moneySection:Button({
    Title = "Auto Rob Electronics",
    Callback = function()
        if isMoving then
            VroyFamilyWindow:Notify({Title = "Vroy Family", Content = "Auto-robbery already in progress."})
            return
        end
        task.spawn(function()
            local originalHolds = {}
            local function restore()
                for p, d in pairs(originalHolds) do
                    if p and p.Parent then p.HoldDuration = d end
                end
            end
            for _, v in ipairs(workspace:GetDescendants()) do
                if v.ClassName == "ProximityPrompt" then
                    originalHolds[v] = v.HoldDuration;
                    v.HoldDuration = 0
                end
            end;
            task.wait(0.3)
            local steps = {
                {N="Phone 1", P=Vector3.new(706.48, 317.36, -68.72), L=Vector3.new(0,0,1)},
                {N="Phone 2", P=Vector3.new(705.51, 317.36, -68.24), L=Vector3.new(0,0,1)},
                {N="Phone 3", P=Vector3.new(704.51, 317.36, -68.37), L=Vector3.new(0,0,1)},
                {N="Phone 4", P=Vector3.new(703.58, 317.36, -68.35), L=Vector3.new(0,0,1)},
                {N="Phone 5", P=Vector3.new(702.25, 317.36, -68.46), L=Vector3.new(0,0,1)},
                {N="Laptop 1", P=Vector3.new(697.6, 317.44, -68.3), L=Vector3.new(0,0,1)},
                {N="Laptop 2", P=Vector3.new(694.72, 317.36, -68.15), L=Vector3.new(0,0,1)},
                {N="Phone 6", P=Vector3.new(686.85, 317.36, -79.66), L=Vector3.new(0,0,-1)},
                {N="Phone 7", P=Vector3.new(688.1, 317.36, -79.95), L=Vector3.new(0,0,-1)},
                {N="Phone 8", P=Vector3.new(689.22, 317.36, -79.89), L=Vector3.new(0,0,-1)},
                {N="Phone 9", P=Vector3.new(689.78, 317.36, -80.3), L=Vector3.new(0,0,-1)},
                {N="Phone 10", P=Vector3.new(691.04, 317.36, -80.41), L=Vector3.new(0,0,-1)},
                {N="TV 1", P=Vector3.new(700.92, 317.36, -81.48), L=Vector3.new(0,0,-1)},
                {N="TV 2", P=Vector3.new(705.91, 317.36, -81.57), L=Vector3.new(0,0,-1)}
            }
            for i, step in ipairs(steps) do
                if not LocalPlayer.Character then restore(); return end
                VroyFamilyWindow:Notify({Title = "Vroy Family", Content = "Robbing " .. step.N .. " (" .. i .. "/" .. #steps .. ")"})
                sitAndTeleport(step.P, step.L);
                task.wait(0.1)
                VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.E, false, game);
                task.wait(0.1);
                VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.E, false, game)
                task.wait(0.2)
            end
            VroyFamilyWindow:Notify({Title = "Vroy Family", Content = "Auto-robbery complete."})
            restore()
        end)
    end,
})

moneySection:Button({
    Title = "Frosts Car Steal",
    Callback = function()
        VroyFamilyWindow:Dialog({
            Title = "Car Teleporter",
            Content = "Please wait, searching for cars...",
            Buttons = {}
        })

        local carTpSection = VroyFamilyWindow:Section({Title = "Available Cars"})
        local vehiclesFolder = workspace:WaitForChild("Vehicles")
        if not vehiclesFolder then return end

        for i, vehicle in ipairs(vehiclesFolder:GetChildren()) do
            if vehicle:IsA("Model") then
                local seat = vehicle:FindFirstChild("Body") and vehicle.Body:FindFirstChild("FRSeat")
                if seat and seat:IsA("BasePart") then
                    local carName = vehicle.Name
                    local carPos = seat.Position
                    local posText = string.format("(%.0f, %.0f, %.0f)", carPos.X, carPos.Y, carPos.Z)
                    carTpSection:Button({
                        Title = carName .. " - " .. posText,
                        Callback = function()
                            if LocalPlayer.Character then
                                sitAndTeleport(seat.Position, seat.CFrame.LookVector)
                            else
                                VroyFamilyWindow:Notify({Title = "Vroy Family", Content = "Your character is not loaded."})
                            end
                        end,
                    })
                end
            end
        end
    end,
})

moneySection:Button({
    Title = "Printer Teleporter",
    Callback = function()
        VroyFamilyWindow:Dialog({
            Title = "Printer Teleporter",
            Content = "Please wait, searching for printers...",
            Buttons = {}
        })
        
        local printerTpSection = VroyFamilyWindow:Section({Title = "Available Printers"})
        local repzFolder = workspace:FindFirstChild("RepzMachines")
        if not repzFolder then return end

        for i, printerModel in ipairs(repzFolder:GetChildren()) do
            if printerModel:IsA("Model") then
                local targetPart = printerModel:FindFirstChild("PrintBase") or (printerModel:FindFirstChild("Base") and printerModel.Base.PrimaryPart)
                if targetPart and targetPart:IsA("BasePart") then
                    local printerPos = targetPart.Position
                    local posText = string.format("(%.0f, %.0f, %.0f)", printerPos.X, printerPos.Y, printerPos.Z)
                    printerTpSection:Button({
                        Title = "Printer " .. i .. " - " .. posText,
                        Callback = function()
                            if LocalPlayer.Character then
                                sitAndTeleport(printerPos, LocalPlayer.Character.PrimaryPart.CFrame.LookVector)
                            else
                                VroyFamilyWindow:Notify({Title = "Vroy Family", Content = "Your character is not loaded."})
                            end
                        end,
                    })
                end
            end
        end
    end,
})


--- Misc Tab Content ---
local miscSection = miscTab:Section({Title = "Player"})
miscSection:Toggle({
    Title = "Fly",
    Value = flyEnabled,
    Callback = function(s)
        if s then
            enableFly()
        else
            disableFly()
        end
    end,
})

miscSection:Slider({
    Title = "Fly Speed",
    Value = {Min = 10, Max = 200, Default = currentFlySpeed},
    Step = 1,
    Callback = function(v) currentFlySpeed = v end,
})

miscSection:Toggle({
    Title = "No Clip",
    Value = false,
    Callback = function(s)
        noClipEnabled=s;
        if not s and LocalPlayer.Character then
            for _,p in ipairs(LocalPlayer.Character:GetDescendants()) do
                if p:IsA("BasePart") then p.CanCollide=true end
            end
        end
    end,
})

miscSection:Toggle({
    Title = "Anti-AFK",
    Value = false,
    Callback = function(s) antiAfkEnabled = s end,
})

miscSection:Toggle({
    Title = "Fullbright",
    Value = false,
    Callback = function(s)
        fullbrightEnabled=s;
        Lighting.Brightness=s and 1 or defaultBrightness;
        Lighting.OutdoorAmbient=s and Color3.new(1,1,1) or defaultOutdoorAmbient
    end,
})

local customName = "ðŸ”¥ FrostsHub ðŸ”¥"
miscSection:Input({
    Title = "Name Changer",
    Placeholder = "Enter custom name",
    Callback = function(text) customName = text end,
})

local _, updateNameChangerToggle = miscSection:Toggle({
    Title = "Enable Name Changer",
    Value = false,
    Callback = function(state)
        if state then
            -- Toggled ON
            if not customName or customName:gsub("%s", "") == "" then
                VroyFamilyWindow:Notify({Title = "Vroy Family", Content = "Please enter a name first."})
                pcall(updateNameChangerToggle, false)
                return
            end
            if nameChangerCoroutine then task.cancel(nameChangerCoroutine) end
            nameChangerCoroutine = task.spawn(function()
                while task.wait(0.5) do
                    pcall(function()
                        local nameLabel = LocalPlayer.Character.Head.displayGUI.nameLabel
                        nameLabel.Text = customName
                    end)
                end
            end)
        else
            -- Toggled OFF
            if nameChangerCoroutine then task.cancel(nameChangerCoroutine) nameChangerCoroutine = nil end
            pcall(function() local nameLabel = LocalPlayer.Character.Head.displayGUI.nameLabel nameLabel.Text = LocalPlayer.Name end)
        end
    end,
})

--//=========================================================================\\
--|| EVENT CONNECTIONS & INITIALIZATION
--\\=========================================================================//

-- Unload Function
local function unload()
    if nameChangerCoroutine then task.cancel(nameChangerCoroutine); nameChangerCoroutine = nil end
    for _, conn in ipairs(connections) do conn:Disconnect() end; connections = {}
    if aimbotConnection then aimbotConnection:Disconnect(); aimbotConnection = nil end
    if noClipConnection then noClipConnection:Disconnect(); noClipConnection = nil end
    fovCircle:Remove()
    for player, data in pairs(skeletonConnections) do cleanupSkeleton(player) end
    for player, data in pairs(boxConnections) do cleanupInfoESP(player) end
    for player, data in pairs(tracerConnections) do cleanupTracerESP(player) end
    for part, drawingSet in pairs(printerEspDrawings) do if drawingSet.text then drawingSet.text:Remove() end; if drawingSet.line then drawingSet.line:Remove() end end; printerEspDrawings = {}
    for part, drawingSet in pairs(carEspDrawings) do if drawingSet.text then d.text:Remove() end; if d.line then d.line:Remove() end end; carEspDrawings = {}
    VroyFamilyWindow:Close()
end
-- The new UI has built-in close/destroy buttons, so we don't need a custom unload button connection.

-- FOV Circle Loop
table.insert(connections, RunService.RenderStepped:Connect(function()
    if fovCircleEnabled and aimbotEnabled then
        local radius = (math.tan(math.rad(aimbotFOV / 2)) * (Camera.ViewportSize.Y / 2)) / math.tan(math.rad(Camera.FieldOfView / 2))
        fovCircle.Radius = radius
        fovCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
        fovCircle.Visible = true
    else
        fovCircle.Visible = false
    end
end))

-- Printer ESP Loop
local function updatePrinterEsp()
    if not printerESPEnabled then
        for _,d in pairs(printerEspDrawings) do d.text.Visible=false;d.line.Visible=false end; return
    end
    local repz, localHRP = workspace:FindFirstChild("RepzMachines"), LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not repz or not localHRP then
        for _,d in pairs(printerEspDrawings) do d.text.Visible=false;d.line.Visible=false end; return
    end
    local activePrinters = {}
    for _,m in ipairs(repz:GetChildren()) do
        if m:IsA("Model") then
            local base = m:FindFirstChild("PrintBase"); local target = nil
            if base and base:IsA("BasePart") then target=base elseif base and base:IsA("Model") and base.PrimaryPart then target=base.PrimaryPart end
            if target then
                activePrinters[target]=true;
                local dist=(localHRP.Position-target.Position).Magnitude;
                local d=printerEspDrawings[target]
                if not d then d={text=newText(),line=newLine()};printerEspDrawings[target]=d end
                if dist<=espRenderDistance then
                    local pos,onScreen=Camera:WorldToViewportPoint(target.Position)
                    if onScreen then
                        local text="Printer";
                        local s,l=pcall(function() return m:FindFirstChild("Mechine Screen"):FindFirstChild("Display"):FindFirstChild("timeremaining") end)
                        if s and l and l:IsA("TextLabel") then text="Printer: "..l.Text end
                        d.text.Text=text;
                        d.text.Position=Vector2.new(pos.X,pos.Y);
                        d.text.Visible=true;
                        d.text.Color=espPrinterColor;
                        d.text.Size=espTextSize
                        d.line.From=Vector2.new(Camera.ViewportSize.X/2,Camera.ViewportSize.Y);
                        d.line.To=Vector2.new(pos.X,pos.Y);
                        d.line.Visible=true;
                        d.line.Color=espPrinterColor;
                        d.line.Thickness=espThickness
                    else
                        if d then d.text.Visible=false;d.line.Visible=false end
                    end
                else
                    if d then d.text.Visible=false;d.line.Visible=false end
                end
            end
        end
    end
    for p,d in pairs(printerEspDrawings) do
        if not activePrinters[p] then d.text:Remove();d.line:Remove();printerEspDrawings[p]=nil end
    end
end
table.insert(connections, RunService.RenderStepped:Connect(updatePrinterEsp))

-- Car ESP Loop
local function updateCarEsp()
    if not carESPEnabled then
        for _,d in pairs(carEspDrawings) do if d.text then d.text.Visible=false end;if d.line then d.line.Visible=false end end; return
    end
    local vehicles, localHRP = workspace:FindFirstChild("Vehicles"), LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not vehicles or not localHRP then
        for _,d in pairs(carEspDrawings) do if d.text then d.text.Visible=false end;if d.line then d.line.Visible=false end end; return
    end
    local activeCars = {}
    for _,v in ipairs(vehicles:GetChildren()) do
        if v:IsA("Model") then
            local seat=v:FindFirstChild("Drivers Seat")
            if seat and seat:IsA("BasePart") then
                activeCars[seat]=true;
                local dist=(localHRP.Position-seat.Position).Magnitude;
                local d=carEspDrawings[seat]
                if not d then d={text=newText(),line=newLine()};carEspDrawings[seat]=d end
                if dist<=espRenderDistance then
                    local pos,onScreen=Camera:WorldToViewportPoint(seat.Position)
                    if onScreen then
                        d.text.Text="Car";
                        d.text.Position=Vector2.new(pos.X,pos.Y);
                        d.text.Visible=true;
                        d.text.Color=espCarColor;
                        d.text.Size=espTextSize
                        d.line.From=Vector2.new(Camera.ViewportSize.X/2,Camera.ViewportSize.Y);
                        d.line.To=Vector2.new(pos.X,pos.Y);
                        d.line.Visible=true;
                        d.line.Color=espCarColor;
                        d.line.Thickness=espThickness
                    else
                        if d then d.text.Visible=false;d.line.Visible=false end
                    end
                else
                    if d then d.text.Visible=false;d.line.Visible=false end
                end
            end
        end
    end
    for p,d in pairs(carEspDrawings) do
        if not activeCars[p] then d.text:Remove();d.line:Remove();carEspDrawings[p]=nil end
    end
end
table.insert(connections, RunService.RenderStepped:Connect(updateCarEsp))

-- Input Handlers
table.insert(connections, UserInputService.InputBegan:Connect(function(input, gpe)
    if gpe then return end
    -- The UI library handles the ToggleKey, so we only need to manage aimbot here
    if (input.UserInputType == Settings.Aimbot_Key or input.KeyCode == Settings.Aimbot_Controller) and aimbotEnabled and not aimbotConnection then
        aimbotConnection = RunService.RenderStepped:Connect(aimbotLoop)
    end
end))

table.insert(connections, UserInputService.InputEnded:Connect(function(input, gpe)
    if gpe then return end
    if (input.UserInputType == Settings.Aimbot_Key or input.KeyCode == Settings.Aimbot_Controller) and aimbotConnection then
        aimbotConnection:Disconnect();
        aimbotConnection = nil
    end
end))

-- Character/Player Events
local function onCharacter(character)
    if flyEnabled then disableFly() end
end
table.insert(connections, LocalPlayer.CharacterAdded:Connect(onCharacter))

table.insert(connections, Players.PlayerAdded:Connect(function(player)
    updatePlayerESP(player, true)
end))

table.insert(connections, Players.PlayerRemoving:Connect(function(player)
    updatePlayerESP(player, false)
end))

-- Continuous Loops
noClipConnection = RunService.Stepped:Connect(function()
    if noClipEnabled and LocalPlayer.Character then
        for _,p in ipairs(LocalPlayer.Character:GetDescendants()) do
            if p:IsA("BasePart") then p.CanCollide = false end
        end
    end
end)
table.insert(connections, noClipConnection)
table.insert(connections, RunService.Stepped:Connect(function()
    if antiAfkEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid") and tick() % 60 < 1 then
        LocalPlayer.Character.Humanoid.Jump = true
    end
end))

-- Initial Setup
for _, player in pairs(Players:GetPlayers()) do
    updatePlayerESP(player, true)
end
if LocalPlayer.Character then
    onCharacter(LocalPlayer.Character)
end

-- Wait for UI to be ready, then delete old loading GUIs
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local loadingGui = playerGui:WaitForChild("LoadingGUI", 10)
if loadingGui then
    print("[DEBUG] Found LoadingGUI, deleting...")
    loadingGui:Destroy()
else
    warn("[DEBUG] LoadingGUI not found!")
end

local camera = Workspace:WaitForChild("Camera", 10)
local blur = camera:FindFirstChild("Blur")
if blur then
    print("[DEBUG] Found Blur inside Camera, deleting...")
    blur:Destroy()
else
    warn("[DEBUG] Blur not found inside Camera!")
end

local remote = ReplicatedStorage:WaitForChild("whitney")
local arguments = {}
print("[DEBUG] Firing remote:", remote.Name)
remote:FireServer(unpack(arguments))
